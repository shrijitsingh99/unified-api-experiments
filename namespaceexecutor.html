<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unified Executors: executor Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unified Executors
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">executor Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceexecutor_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexecutor_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1allocator__t.html">allocator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property for customizing memory allocation.  <a href="structexecutor_1_1allocator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1allocator__t_3_01void_01_4.html">allocator_t&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1base__executor__property.html">base_executor_property</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for all properties, containing the common functionality needed by all properties.  <a href="structexecutor_1_1base__executor__property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1blocking__t.html">blocking_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A behavioral property that guarantees executors provide about the blocking behavior of their execution functions.  <a href="structexecutor_1_1blocking__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1can__prefer.html">can_prefer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given Property and Executor support the prefer customization point.  <a href="structexecutor_1_1can__prefer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1can__prefer_3_01Executor_00_01Property_00_01void__t_3_01decltype_07prefer_07steb9e1ecedcba32b4267b1e6164401bec.html">can_prefer&lt; Executor, Property, void_t&lt; decltype(prefer(std::declval&lt; Executor &gt;(), std::declval&lt; Property &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1can__query.html">can_query</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given Property and Executor support the query customization point.  <a href="structexecutor_1_1can__query.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1can__query_3_01Executor_00_01Property_00_01void__t_3_01decltype_07query_07std_30b2de1c24fa170e1912d64139a6dc1b.html">can_query&lt; Executor, Property, void_t&lt; decltype(query(std::declval&lt; Executor &gt;(), std::declval&lt; Property &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1can__require.html">can_require</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given Property and Executor support the require customization point.  <a href="structexecutor_1_1can__require.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1can__require_3_01Executor_00_01Property_00_01void__t_3_01decltype_07require_07e1706e672f4de3b53bc86c565bd22f06.html">can_require&lt; Executor, Property, void_t&lt; decltype(require(std::declval&lt; Executor &gt;(), std::declval&lt; Property &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1cuda__executor.html">cuda_executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1disjunction.html">disjunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1disjunction_3_01Cond_00_01Conds_8_8_8_01_4.html">disjunction&lt; Cond, Conds... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1equality__comparable.html">equality_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1equality__comparable_3_01T1_00_01T2_00_01executor_1_1void__t_3_01decltype_07st3f309e7f8df62f2c3048884b7f94bb16.html">equality_comparable&lt; T1, T2, executor::void_t&lt; decltype(std::declval&lt; T1 &gt;()==std::declval&lt; T2 &gt;(), std::declval&lt; T2 &gt;()==std::declval&lt; T1 &gt;(), std::declval&lt; T1 &gt;() !=std::declval&lt; T2 &gt;(), std::declval&lt; T2 &gt;() !=std::declval&lt; T1 &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1executor__index.html">executor_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A given Executor can have a custom index for bulk execute.  <a href="structexecutor_1_1executor__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1executor__index_3_01Executor_00_01executor_1_1void__t_3_01typename_01Executor_1_1index__type_01_4_01_4.html">executor_index&lt; Executor, executor::void_t&lt; typename Executor::index_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1executor__runtime__checks.html">executor_runtime_checks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1executor__shape.html">executor_shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A given Executor can have a custom shape for bulk execute.  <a href="structexecutor_1_1executor__shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1executor__shape_3_01Executor_00_01executor_1_1void__t_3_01typename_01Executor_1_1shape__type_01_4_01_4.html">executor_shape&lt; Executor, executor::void_t&lt; typename Executor::shape_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1filter__tuple__values.html">filter_tuple_values</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1filter__tuple__values_3_01predicate_00_01const_01std_1_1tuple_3_01T_8_8_8_01_4_01_4.html">filter_tuple_values&lt; predicate, const std::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1filter__tuple__values_3_01predicate_00_01std_1_1tuple_3_01T_8_8_8_01_4_01_4.html">filter_tuple_values&lt; predicate, std::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1inline__executor.html">inline_executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1is__executor.html">is_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the type is an executor.  <a href="structexecutor_1_1is__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1is__executor_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__copy__constructibl739eb3860bbdee7cbf7a53ee058663f3.html">is_executor&lt; T, std::enable_if_t&lt; std::is_copy_constructible&lt; T &gt;::value &amp;&amp;detail::contains_execute&lt; T &gt;::value &amp;&amp;executor::equality_comparable&lt; T, T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1is__executor__available.html">is_executor_available</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given executor is available to use.  <a href="structexecutor_1_1is__executor__available.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1is__executor__available_3_01inline__executor_01_4.html">is_executor_available&lt; inline_executor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1is__executor__instance__available.html">is_executor_instance_available</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1is__executor__instance__available_3_01Executor_3_01Properties_8_8_8_01_4_01_4.html">is_executor_instance_available&lt; Executor&lt; Properties... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1omp__executor.html">omp_executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexecutor_1_1sse__executor.html">sse_executor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeb98f1041f9cda3e36f8173595e44077"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#aeb98f1041f9cda3e36f8173595e44077">default_cuda_executor</a> = <a class="el" href="structexecutor_1_1cuda__executor.html">cuda_executor</a>&lt;&gt;</td></tr>
<tr class="separator:aeb98f1041f9cda3e36f8173595e44077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ff61fef9ffb3ac098a857a50c4f58d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a76ff61fef9ffb3ac098a857a50c4f58d">default_inline_executor</a> = <a class="el" href="structexecutor_1_1inline__executor.html">inline_executor</a>&lt;&gt;</td></tr>
<tr class="separator:a76ff61fef9ffb3ac098a857a50c4f58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf3a87b007c59d630c3e870569f81db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a1cf3a87b007c59d630c3e870569f81db">default_omp_executor</a> = <a class="el" href="structexecutor_1_1omp__executor.html">omp_executor</a>&lt;&gt;</td></tr>
<tr class="separator:a1cf3a87b007c59d630c3e870569f81db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e04788880cdb22bb41b540df8a5c94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a97e04788880cdb22bb41b540df8a5c94">default_sse_executor</a> = <a class="el" href="structexecutor_1_1sse__executor.html">sse_executor</a>&lt;&gt;</td></tr>
<tr class="separator:a97e04788880cdb22bb41b540df8a5c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12383619106dbc0512847f7571325e47"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:a12383619106dbc0512847f7571325e47"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a12383619106dbc0512847f7571325e47">void_t</a> = void</td></tr>
<tr class="separator:a12383619106dbc0512847f7571325e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f56986a761a0fcf69d20817f097d618"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f56986a761a0fcf69d20817f097d618"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a0f56986a761a0fcf69d20817f097d618">remove_cv_ref_t</a> = std::remove_cv_t&lt; std::remove_reference_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:a0f56986a761a0fcf69d20817f097d618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540427e71b8a9bb9957aedad7e25572"><td class="memTemplParams" colspan="2">template&lt;typename Executor , template&lt; typename... &gt; class... Type&gt; </td></tr>
<tr class="memitem:ae540427e71b8a9bb9957aedad7e25572"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#ae540427e71b8a9bb9957aedad7e25572">is_instance_of_any</a> = <a class="el" href="structexecutor_1_1disjunction.html">executor::disjunction</a>&lt; <a class="el" href="structexecutor_1_1detail_1_1is__instance__of__any__impl.html">detail::is_instance_of_any_impl</a>&lt; Executor, Type &gt;... &gt;</td></tr>
<tr class="separator:ae540427e71b8a9bb9957aedad7e25572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120134f9cae492a79fdab86ddb61774f"><td class="memTemplParams" colspan="2">template&lt;typename Executor , template&lt; typename... &gt; class... Type&gt; </td></tr>
<tr class="memitem:a120134f9cae492a79fdab86ddb61774f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a120134f9cae492a79fdab86ddb61774f">InstanceOfAny</a> = std::enable_if_t&lt; <a class="el" href="namespaceexecutor.html#a646669ebe36b2bf5666c89def8dc2529">is_instance_of_any_v</a>&lt; Executor, Type... &gt;, int &gt;</td></tr>
<tr class="separator:a120134f9cae492a79fdab86ddb61774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c98e431bc4f2df0d75cf46f91713927"><td class="memTemplParams" colspan="2">template&lt;typename Executor , template&lt; typename... &gt; class Type&gt; </td></tr>
<tr class="memitem:a6c98e431bc4f2df0d75cf46f91713927"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a6c98e431bc4f2df0d75cf46f91713927">InstanceOf</a> = std::enable_if_t&lt; <a class="el" href="namespaceexecutor.html#a646669ebe36b2bf5666c89def8dc2529">is_instance_of_any_v</a>&lt; Executor, Type &gt;, int &gt;</td></tr>
<tr class="separator:a6c98e431bc4f2df0d75cf46f91713927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf44f039bc3a9ba7e6c4a5639ebf6ba"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1bf44f039bc3a9ba7e6c4a5639ebf6ba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a1bf44f039bc3a9ba7e6c4a5639ebf6ba">is_same_template</a> = <a class="el" href="structexecutor_1_1detail_1_1is__same__template__impl.html">detail::is_same_template_impl</a>&lt; <a class="el" href="namespaceexecutor.html#a0f56986a761a0fcf69d20817f097d618">executor::remove_cv_ref_t</a>&lt; T1 &gt;, <a class="el" href="namespaceexecutor.html#a0f56986a761a0fcf69d20817f097d618">executor::remove_cv_ref_t</a>&lt; T2 &gt; &gt;</td></tr>
<tr class="separator:a1bf44f039bc3a9ba7e6c4a5639ebf6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410b014f6f3d3940584e31c99c6d65e2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a410b014f6f3d3940584e31c99c6d65e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a410b014f6f3d3940584e31c99c6d65e2">tuple_contains_type</a> = typename <a class="el" href="structexecutor_1_1detail_1_1tuple__contains__type__impl.html">detail::tuple_contains_type_impl</a>&lt; T, Tuple &gt;::type</td></tr>
<tr class="separator:a410b014f6f3d3940584e31c99c6d65e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04681556d82276b50ba55a04587ac035"><td class="memTemplParams" colspan="2">template&lt;class Executor &gt; </td></tr>
<tr class="memitem:a04681556d82276b50ba55a04587ac035"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a04681556d82276b50ba55a04587ac035">executor_index_t</a> = typename <a class="el" href="structexecutor_1_1executor__index.html">executor_index</a>&lt; Executor &gt;::type</td></tr>
<tr class="separator:a04681556d82276b50ba55a04587ac035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e333dde2706928044590686cc829691"><td class="memTemplParams" colspan="2">template&lt;class Executor &gt; </td></tr>
<tr class="memitem:a5e333dde2706928044590686cc829691"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a5e333dde2706928044590686cc829691">executor_shape_t</a> = typename <a class="el" href="structexecutor_1_1executor__shape.html">executor_shape</a>&lt; Executor &gt;::type</td></tr>
<tr class="separator:a5e333dde2706928044590686cc829691"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1a401e6560a8eee64f6a5547c5f76c4f"><td class="memTemplParams" colspan="2">template&lt;typename RuntimeChecks  = executor_runtime_checks, typename Function , typename... SupportedExecutors&gt; </td></tr>
<tr class="memitem:a1a401e6560a8eee64f6a5547c5f76c4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a1a401e6560a8eee64f6a5547c5f76c4f">enable_exec_with_priority</a> (Function &amp;&amp;f, std::tuple&lt; SupportedExecutors... &gt; supported_execs)</td></tr>
<tr class="separator:a1a401e6560a8eee64f6a5547c5f76c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971ea6d35730d5f1974a9c6786c3cf81"><td class="memTemplParams" colspan="2">template&lt;typename RuntimeChecks  = executor_runtime_checks, typename Function , typename... SupportedExecutors&gt; </td></tr>
<tr class="memitem:a971ea6d35730d5f1974a9c6786c3cf81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a971ea6d35730d5f1974a9c6786c3cf81">enable_exec_with_priority</a> (Function &amp;&amp;f, SupportedExecutors &amp;&amp;... execs)</td></tr>
<tr class="separator:a971ea6d35730d5f1974a9c6786c3cf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3ccb7d91f6afb4bbdfa84c0f8351f9"><td class="memTemplParams" colspan="2">template&lt;typename RuntimeChecks  = executor_runtime_checks, typename Function , typename... SupportedExecutors&gt; </td></tr>
<tr class="memitem:a7f3ccb7d91f6afb4bbdfa84c0f8351f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a7f3ccb7d91f6afb4bbdfa84c0f8351f9">enable_exec_on_desc_priority</a> (Function &amp;&amp;f, std::tuple&lt; SupportedExecutors... &gt; supported_execs)</td></tr>
<tr class="separator:a7f3ccb7d91f6afb4bbdfa84c0f8351f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cf7a5c9efbddf55cfd846b51da9b63"><td class="memTemplParams" colspan="2">template&lt;typename RuntimeChecks  = executor_runtime_checks, typename Function , typename... SupportedExecutors&gt; </td></tr>
<tr class="memitem:af6cf7a5c9efbddf55cfd846b51da9b63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#af6cf7a5c9efbddf55cfd846b51da9b63">enable_exec_on_desc_priority</a> (Function &amp;&amp;f, SupportedExecutors &amp;&amp;... supported_execs)</td></tr>
<tr class="separator:af6cf7a5c9efbddf55cfd846b51da9b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0e70e881f5598a8a9e1a7667fd8a35"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename Property , typename std::enable_if_t&lt; Property::template is_applicable_property&lt; Executor &gt;::value &amp;&amp;Property::is_preferable &amp;&amp;can_require_v&lt; Executor, Property &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5d0e70e881f5598a8a9e1a7667fd8a35"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a5d0e70e881f5598a8a9e1a7667fd8a35">prefer</a> (const Executor &amp;ex, const Property &amp;p) noexcept</td></tr>
<tr class="memdesc:a5d0e70e881f5598a8a9e1a7667fd8a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces a specified Property on an Executor if possible else returns the same Executor.  <a href="namespaceexecutor.html#a5d0e70e881f5598a8a9e1a7667fd8a35">More...</a><br /></td></tr>
<tr class="separator:a5d0e70e881f5598a8a9e1a7667fd8a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3b6a601d6761a2692e73afd9e9d84d"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename Property , typename std::enable_if_t&lt; Property::template is_applicable_property&lt; Executor &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0e3b6a601d6761a2692e73afd9e9d84d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a0e3b6a601d6761a2692e73afd9e9d84d">query</a> (Executor &amp;&amp;ex, const Property &amp;p) noexcept</td></tr>
<tr class="memdesc:a0e3b6a601d6761a2692e73afd9e9d84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a specified Property on an Executor is supported by the Executor.  <a href="namespaceexecutor.html#a0e3b6a601d6761a2692e73afd9e9d84d">More...</a><br /></td></tr>
<tr class="separator:a0e3b6a601d6761a2692e73afd9e9d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231b06deb4adb6e1e59b4af0c0b358a4"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename Property , typename std::enable_if_t&lt; Property::template is_applicable_property&lt; Executor &gt;::value &amp;&amp;Property::is_requirable &amp;&amp;detail::contains_property&lt; Executor, Property &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a231b06deb4adb6e1e59b4af0c0b358a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a231b06deb4adb6e1e59b4af0c0b358a4">require</a> (const Executor &amp;ex, const Property &amp;p) noexcept</td></tr>
<tr class="memdesc:a231b06deb4adb6e1e59b4af0c0b358a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces a specified Property on an Executor. A new executor instance which implements that property is created and returned.  <a href="namespaceexecutor.html#a231b06deb4adb6e1e59b4af0c0b358a4">More...</a><br /></td></tr>
<tr class="separator:a231b06deb4adb6e1e59b4af0c0b358a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4729687784d9afe68722f4b747869f0"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename FunctionType &gt; </td></tr>
<tr class="memitem:ac4729687784d9afe68722f4b747869f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#ac4729687784d9afe68722f4b747869f0">for_each_until_true</a> (TupleType &amp;&amp;, FunctionType, std::integral_constant&lt; std::size_t, std::tuple_size&lt; typename std::remove_reference&lt; TupleType &gt;::type &gt;::value &gt;)</td></tr>
<tr class="separator:ac4729687784d9afe68722f4b747869f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba872f91ec49492d8bf9792367eceb20"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename TupleType , typename FunctionType , typename  = typename std::enable_if&lt;              I != std::tuple_size&lt;typename std::remove_reference&lt;                       TupleType&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aba872f91ec49492d8bf9792367eceb20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#aba872f91ec49492d8bf9792367eceb20">for_each_until_true</a> (TupleType &amp;&amp;t, FunctionType f, std::integral_constant&lt; size_t, I &gt;)</td></tr>
<tr class="separator:aba872f91ec49492d8bf9792367eceb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7dce3fbd67371a55fc83f53c647a6d"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename FunctionType &gt; </td></tr>
<tr class="memitem:a9a7dce3fbd67371a55fc83f53c647a6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a9a7dce3fbd67371a55fc83f53c647a6d">for_each_until_true</a> (TupleType &amp;&amp;t, FunctionType f)</td></tr>
<tr class="separator:a9a7dce3fbd67371a55fc83f53c647a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae23e2b4aade24c5acf3fab6824352abd"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename Property &gt; </td></tr>
<tr class="memitem:ae23e2b4aade24c5acf3fab6824352abd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#ae23e2b4aade24c5acf3fab6824352abd">can_prefer_v</a> = <a class="el" href="structexecutor_1_1can__prefer.html">can_prefer</a>&lt;Executor, Property&gt;::value</td></tr>
<tr class="separator:ae23e2b4aade24c5acf3fab6824352abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297dbdc827c1bf6c06a9f2801c7549a"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename Property &gt; </td></tr>
<tr class="memitem:a6297dbdc827c1bf6c06a9f2801c7549a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a6297dbdc827c1bf6c06a9f2801c7549a">can_query_v</a> = <a class="el" href="structexecutor_1_1can__query.html">can_query</a>&lt;Executor, Property&gt;::value</td></tr>
<tr class="separator:a6297dbdc827c1bf6c06a9f2801c7549a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b00253cb5b68dbdf223c00b58fc8f78"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename Property &gt; </td></tr>
<tr class="memitem:a8b00253cb5b68dbdf223c00b58fc8f78"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a8b00253cb5b68dbdf223c00b58fc8f78">can_require_v</a> = <a class="el" href="structexecutor_1_1can__require.html">can_require</a>&lt;Executor, Property&gt;::value</td></tr>
<tr class="separator:a8b00253cb5b68dbdf223c00b58fc8f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506a34d0f4185a9936a019807234ff12"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a506a34d0f4185a9936a019807234ff12"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a506a34d0f4185a9936a019807234ff12">equality_comparable_v</a> = <a class="el" href="structexecutor_1_1equality__comparable.html">equality_comparable</a>&lt;T1, T2&gt;::value</td></tr>
<tr class="separator:a506a34d0f4185a9936a019807234ff12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646669ebe36b2bf5666c89def8dc2529"><td class="memTemplParams" colspan="2">template&lt;typename Executor , template&lt; typename... &gt; class... Type&gt; </td></tr>
<tr class="memitem:a646669ebe36b2bf5666c89def8dc2529"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceexecutor.html#a646669ebe36b2bf5666c89def8dc2529">is_instance_of_any_v</a></td></tr>
<tr class="separator:a646669ebe36b2bf5666c89def8dc2529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aeb98f1041f9cda3e36f8173595e44077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb98f1041f9cda3e36f8173595e44077">&#9670;&nbsp;</a></span>default_cuda_executor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#aeb98f1041f9cda3e36f8173595e44077">executor::default_cuda_executor</a> = typedef <a class="el" href="structexecutor_1_1cuda__executor.html">cuda_executor</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76ff61fef9ffb3ac098a857a50c4f58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ff61fef9ffb3ac098a857a50c4f58d">&#9670;&nbsp;</a></span>default_inline_executor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a76ff61fef9ffb3ac098a857a50c4f58d">executor::default_inline_executor</a> = typedef <a class="el" href="structexecutor_1_1inline__executor.html">inline_executor</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cf3a87b007c59d630c3e870569f81db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf3a87b007c59d630c3e870569f81db">&#9670;&nbsp;</a></span>default_omp_executor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a1cf3a87b007c59d630c3e870569f81db">executor::default_omp_executor</a> = typedef <a class="el" href="structexecutor_1_1omp__executor.html">omp_executor</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97e04788880cdb22bb41b540df8a5c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e04788880cdb22bb41b540df8a5c94">&#9670;&nbsp;</a></span>default_sse_executor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a97e04788880cdb22bb41b540df8a5c94">executor::default_sse_executor</a> = typedef <a class="el" href="structexecutor_1_1sse__executor.html">sse_executor</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04681556d82276b50ba55a04587ac035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04681556d82276b50ba55a04587ac035">&#9670;&nbsp;</a></span>executor_index_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a04681556d82276b50ba55a04587ac035">executor::executor_index_t</a> = typedef typename <a class="el" href="structexecutor_1_1executor__index.html">executor_index</a>&lt;Executor&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e333dde2706928044590686cc829691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e333dde2706928044590686cc829691">&#9670;&nbsp;</a></span>executor_shape_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Executor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a5e333dde2706928044590686cc829691">executor::executor_shape_t</a> = typedef typename <a class="el" href="structexecutor_1_1executor__shape.html">executor_shape</a>&lt;Executor&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c98e431bc4f2df0d75cf46f91713927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c98e431bc4f2df0d75cf46f91713927">&#9670;&nbsp;</a></span>InstanceOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , template&lt; typename... &gt; class Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a6c98e431bc4f2df0d75cf46f91713927">executor::InstanceOf</a> = typedef std::enable_if_t&lt;<a class="el" href="namespaceexecutor.html#a646669ebe36b2bf5666c89def8dc2529">is_instance_of_any_v</a>&lt;Executor, Type&gt;, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a120134f9cae492a79fdab86ddb61774f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120134f9cae492a79fdab86ddb61774f">&#9670;&nbsp;</a></span>InstanceOfAny</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , template&lt; typename... &gt; class... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a120134f9cae492a79fdab86ddb61774f">executor::InstanceOfAny</a> = typedef std::enable_if_t&lt;<a class="el" href="namespaceexecutor.html#a646669ebe36b2bf5666c89def8dc2529">is_instance_of_any_v</a>&lt;Executor, Type...&gt;, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae540427e71b8a9bb9957aedad7e25572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae540427e71b8a9bb9957aedad7e25572">&#9670;&nbsp;</a></span>is_instance_of_any</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , template&lt; typename... &gt; class... Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#ae540427e71b8a9bb9957aedad7e25572">executor::is_instance_of_any</a> = typedef <a class="el" href="structexecutor_1_1disjunction.html">executor::disjunction</a>&lt;<a class="el" href="structexecutor_1_1detail_1_1is__instance__of__any__impl.html">detail::is_instance_of_any_impl</a>&lt;Executor, Type&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bf44f039bc3a9ba7e6c4a5639ebf6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf44f039bc3a9ba7e6c4a5639ebf6ba">&#9670;&nbsp;</a></span>is_same_template</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a1bf44f039bc3a9ba7e6c4a5639ebf6ba">executor::is_same_template</a> = typedef <a class="el" href="structexecutor_1_1detail_1_1is__same__template__impl.html">detail::is_same_template_impl</a>&lt;<a class="el" href="namespaceexecutor.html#a0f56986a761a0fcf69d20817f097d618">executor::remove_cv_ref_t</a>&lt;T1&gt;, <a class="el" href="namespaceexecutor.html#a0f56986a761a0fcf69d20817f097d618">executor::remove_cv_ref_t</a>&lt;T2&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f56986a761a0fcf69d20817f097d618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f56986a761a0fcf69d20817f097d618">&#9670;&nbsp;</a></span>remove_cv_ref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a0f56986a761a0fcf69d20817f097d618">executor::remove_cv_ref_t</a> = typedef std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a410b014f6f3d3940584e31c99c6d65e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410b014f6f3d3940584e31c99c6d65e2">&#9670;&nbsp;</a></span>tuple_contains_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a410b014f6f3d3940584e31c99c6d65e2">executor::tuple_contains_type</a> = typedef typename <a class="el" href="structexecutor_1_1detail_1_1tuple__contains__type__impl.html">detail::tuple_contains_type_impl</a>&lt;T, Tuple&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12383619106dbc0512847f7571325e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12383619106dbc0512847f7571325e47">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceexecutor.html#a12383619106dbc0512847f7571325e47">executor::void_t</a> = typedef void</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Part of Standard Library in C++17 onwards </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7f3ccb7d91f6afb4bbdfa84c0f8351f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3ccb7d91f6afb4bbdfa84c0f8351f9">&#9670;&nbsp;</a></span>enable_exec_on_desc_priority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RuntimeChecks  = executor_runtime_checks, typename Function , typename... SupportedExecutors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void executor::enable_exec_on_desc_priority </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; SupportedExecutors... &gt;&#160;</td>
          <td class="paramname"><em>supported_execs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6cf7a5c9efbddf55cfd846b51da9b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cf7a5c9efbddf55cfd846b51da9b63">&#9670;&nbsp;</a></span>enable_exec_on_desc_priority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RuntimeChecks  = executor_runtime_checks, typename Function , typename... SupportedExecutors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void executor::enable_exec_on_desc_priority </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SupportedExecutors &amp;&amp;...&#160;</td>
          <td class="paramname"><em>supported_execs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a401e6560a8eee64f6a5547c5f76c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a401e6560a8eee64f6a5547c5f76c4f">&#9670;&nbsp;</a></span>enable_exec_with_priority() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RuntimeChecks  = executor_runtime_checks, typename Function , typename... SupportedExecutors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void executor::enable_exec_with_priority </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; SupportedExecutors... &gt;&#160;</td>
          <td class="paramname"><em>supported_execs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a971ea6d35730d5f1974a9c6786c3cf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971ea6d35730d5f1974a9c6786c3cf81">&#9670;&nbsp;</a></span>enable_exec_with_priority() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RuntimeChecks  = executor_runtime_checks, typename Function , typename... SupportedExecutors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void executor::enable_exec_with_priority </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SupportedExecutors &amp;&amp;...&#160;</td>
          <td class="paramname"><em>execs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4729687784d9afe68722f4b747869f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4729687784d9afe68722f4b747869f0">&#9670;&nbsp;</a></span>for_each_until_true() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType , typename FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void executor::for_each_until_true </td>
          <td>(</td>
          <td class="paramtype">TupleType &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integral_constant&lt; std::size_t, std::tuple_size&lt; typename std::remove_reference&lt; TupleType &gt;::type &gt;::value &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a7dce3fbd67371a55fc83f53c647a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7dce3fbd67371a55fc83f53c647a6d">&#9670;&nbsp;</a></span>for_each_until_true() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType , typename FunctionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void executor::for_each_until_true </td>
          <td>(</td>
          <td class="paramtype">TupleType &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba872f91ec49492d8bf9792367eceb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba872f91ec49492d8bf9792367eceb20">&#9670;&nbsp;</a></span>for_each_until_true() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename TupleType , typename FunctionType , typename  = typename std::enable_if&lt;              I != std::tuple_size&lt;typename std::remove_reference&lt;                       TupleType&gt;::type&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void executor::for_each_until_true </td>
          <td>(</td>
          <td class="paramtype">TupleType &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integral_constant&lt; size_t, I &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d0e70e881f5598a8a9e1a7667fd8a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0e70e881f5598a8a9e1a7667fd8a35">&#9670;&nbsp;</a></span>prefer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename Property , typename std::enable_if_t&lt; Property::template is_applicable_property&lt; Executor &gt;::value &amp;&amp;Property::is_preferable &amp;&amp;can_require_v&lt; Executor, Property &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) executor::prefer </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforces a specified Property on an Executor if possible else returns the same Executor. </p>
<p>If enforced a new executor instance which implements that property is created and returned. prefer denotes a customization point and should satisfy the following conditions to be applicable:</p><ol type="1">
<li>The Property should be applicable and preferable which can be checked using Property::template is_applicable_property&lt;Executor&gt;::value and Property::is_preferable</li>
<li>The expression Property::template static_query&lt;Executor&gt;::value == Property::value() should be true, which implies that the Executor supports that property</li>
</ol>
<p>If all the above conditions are met, prefer customization point is valid. If it is possible, then the require customization point is called and the Property is enforced for the Executor. If the above case is not possible, then the same Executor is returned.</p>
<p>Part of Proposal P1393R0</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><ol type="1">
<li>Support multiple querying multiple properties in the trait: template &lt;typename Executor, typename... Properties&gt; </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a0e3b6a601d6761a2692e73afd9e9d84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3b6a601d6761a2692e73afd9e9d84d">&#9670;&nbsp;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename Property , typename std::enable_if_t&lt; Property::template is_applicable_property&lt; Executor &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto executor::query </td>
          <td>(</td>
          <td class="paramtype">Executor &amp;&amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a specified Property on an Executor is supported by the Executor. </p>
<p>If supported it returns the current instance of that Property. prefer denotes a customization point and should satisfy the following conditions to be applicable:</p><ol type="1">
<li>The Property should be applicable which can be checked using Property::template is_applicable_property&lt;Executor&gt;::value</li>
<li>The expression Property::template static_query&lt;Executor&gt;::value should be a valid constant expression</li>
</ol>
<p>If all the above conditions are met, then the overload query member function in the Executor is called with the Property.</p>
<p>Part of Proposal P1393R0 </p>

</div>
</div>
<a id="a231b06deb4adb6e1e59b4af0c0b358a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231b06deb4adb6e1e59b4af0c0b358a4">&#9670;&nbsp;</a></span>require()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename Property , typename std::enable_if_t&lt; Property::template is_applicable_property&lt; Executor &gt;::value &amp;&amp;Property::is_requirable &amp;&amp;detail::contains_property&lt; Executor, Property &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) executor::require </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforces a specified Property on an Executor. A new executor instance which implements that property is created and returned. </p>
<p>require denotes a customization point and should satisfy the following conditions to be applicable:</p><ol type="1">
<li>The Property should be applicable and requirable which can be checked using Property::template is_applicable_property&lt;Executor&gt;::value and Property::is_requirable</li>
<li>The expression Property::template static_query&lt;Executor&gt;::value == Property::value() should be true, which implies that the Executor supports that property</li>
</ol>
<p>If all the above conditions are met, then the overload require member function in the Executor is called with the Property.</p>
<p>Part of Proposal P1393R0</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd><ol type="1">
<li>Return same instance of executor if property is already implemented</li>
<li>Support multiple querying multiple properties in the trait: template &lt;typename Executor, typename... Properties&gt; </li>
</ol>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae23e2b4aade24c5acf3fab6824352abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23e2b4aade24c5acf3fab6824352abd">&#9670;&nbsp;</a></span>can_prefer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename Property &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool executor::can_prefer_v = <a class="el" href="structexecutor_1_1can__prefer.html">can_prefer</a>&lt;Executor, Property&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6297dbdc827c1bf6c06a9f2801c7549a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297dbdc827c1bf6c06a9f2801c7549a">&#9670;&nbsp;</a></span>can_query_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename Property &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool executor::can_query_v = <a class="el" href="structexecutor_1_1can__query.html">can_query</a>&lt;Executor, Property&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b00253cb5b68dbdf223c00b58fc8f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b00253cb5b68dbdf223c00b58fc8f78">&#9670;&nbsp;</a></span>can_require_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename Property &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool executor::can_require_v = <a class="el" href="structexecutor_1_1can__require.html">can_require</a>&lt;Executor, Property&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a506a34d0f4185a9936a019807234ff12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506a34d0f4185a9936a019807234ff12">&#9670;&nbsp;</a></span>equality_comparable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool executor::equality_comparable_v = <a class="el" href="structexecutor_1_1equality__comparable.html">equality_comparable</a>&lt;T1, T2&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a646669ebe36b2bf5666c89def8dc2529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646669ebe36b2bf5666c89def8dc2529">&#9670;&nbsp;</a></span>is_instance_of_any_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , template&lt; typename... &gt; class... Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool executor::is_instance_of_any_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code" href="namespaceexecutor.html#ae540427e71b8a9bb9957aedad7e25572">is_instance_of_any</a>&lt;Executor, Type...&gt;::value</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceexecutor_html_ae540427e71b8a9bb9957aedad7e25572"><div class="ttname"><a href="namespaceexecutor.html#ae540427e71b8a9bb9957aedad7e25572">executor::is_instance_of_any</a></div><div class="ttdeci">executor::disjunction&lt; detail::is_instance_of_any_impl&lt; Executor, Type &gt;... &gt; is_instance_of_any</div><div class="ttdef"><b>Definition:</b> common_traits.hpp:79</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19
</small></address>
</body>
</html>
